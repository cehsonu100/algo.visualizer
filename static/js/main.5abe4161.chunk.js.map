{"version":3,"sources":["logo.svg","DeptFirstSearch/Node/Node.jsx","graph_algorithms/DepthFirstSearch_algo.js","graph_algorithms/BFS_algo.js","DeptFirstSearch/DeptFirstSearch.jsx","App.js","serviceWorker.js","index.js"],"names":["module","exports","Node","this","props","row","col","isStart","isFinish","isWall","onMouseDown","onMouseUp","onMouseEnter","extraClassName","id","className","Component","depth_first_search","grid","startNode","finishNode","visitedNodesInOrder","depth_first_search_utils","node","isVisited","push","unvisitedNeighbors","neighbors","length","filter","neighbor","getUnvisitedNeighbors","i","previousNode","getNodesInShortestPathOrder","nodesInShortestPathOrder","currentNode","unshift","breadth_first_search","queue","pop","unvisitedNeighbors_array","breadth_first_search_utils","DeptFirstSearch","state","mouseIsPressed","getInitialGrid","setState","changedGrid","getNewgridWithWallToggled","newGrid","setTimeout","document","getElementById","animateShortestPath","starNode","animateDFS","onClick","visualizeDeptFirstSearch","visualizeBreadthFirstSearch","map","rowIdx","key","nodeIdx","handleMouseDown","handleMouseUp","handleMouseEnter","currentRow","createNode","distance","Infinity","slice","newNode","App","Boolean","window","location","hostname","match","ReactDOM","render","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.5abe4161.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/logo.5d5d9eef.svg\";","import React, { Component } from \"react\";\r\nimport \"./Node.css\";\r\n\r\nexport default class Node extends Component {\r\n  render() {\r\n    const {\r\n      row,\r\n      col,\r\n      isStart,\r\n      isFinish,\r\n      isWall,\r\n      onMouseDown,\r\n      onMouseUp,\r\n      onMouseEnter\r\n    } = this.props;\r\n    const extraClassName = isFinish\r\n      ? \"node-finish\"\r\n      : isStart\r\n      ? \"node-start\"\r\n      : isWall\r\n      ? \"node-wall\"\r\n      : \"\";\r\n\r\n    return (\r\n      <div\r\n        id={`node-${row}-${col}`}\r\n        className={`node ${extraClassName}`}\r\n        onMouseDown={() => onMouseDown(row, col)}\r\n        onMouseEnter={() => onMouseEnter(row, col)}\r\n        onMouseUp={() => onMouseUp()}\r\n      ></div>\r\n    );\r\n  }\r\n}\r\n","export function depth_first_search(grid, startNode, finishNode) {\r\n    const visitedNodesInOrder = [];\r\n    var isTargetFound = depth_first_search_utils(grid, startNode, finishNode, visitedNodesInOrder);\r\n    // depth_first_search_utils(grid, startNode, finishNode, visitedNodesInOrder);\r\n    return visitedNodesInOrder;\r\n}\r\n\r\nfunction depth_first_search_utils(grid, node, finishNode, visitedNodesInOrder) {\r\n    if (node.row === finishNode.row && node.col === finishNode.col) {\r\n        return true;\r\n    }\r\n    node.isVisited = true;\r\n    if (!node.isStart) {\r\n        visitedNodesInOrder.push(node);\r\n    }\r\n    const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\r\n    for (const i in unvisitedNeighbors) {\r\n        if (unvisitedNeighbors[i].isVisited || unvisitedNeighbors[i].isWall) {\r\n            continue;\r\n        } else {\r\n            // **** current marked visited node will be parent of next visiting node\r\n            unvisitedNeighbors[i].previousNode = node;\r\n            const result = depth_first_search_utils(grid, unvisitedNeighbors[i], finishNode, visitedNodesInOrder);\r\n            if (result === true) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfunction getUnvisitedNeighbors(node, grid) {\r\n    const neighbors = [];\r\n    const { col, row } = node;\r\n    if (row > 0) neighbors.push(grid[row - 1][col]);\r\n    if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n    if (col > 0) neighbors.push(grid[row][col - 1]);\r\n    if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n    return neighbors.filter(neighbor => !neighbor.isVisited);\r\n}\r\n\r\nexport function getNodesInShortestPathOrder(finishNode) {\r\n    const nodesInShortestPathOrder = [];\r\n    let currentNode = finishNode;\r\n\r\n    while (currentNode !== null) {\r\n        nodesInShortestPathOrder.unshift(currentNode);\r\n        currentNode = currentNode.previousNode;\r\n    }\r\n    return nodesInShortestPathOrder;\r\n}\r\n","export function breadth_first_search(grid, startNode, finishNode) {\r\n    const visitedNodesInOrder = [];\r\n    breadth_first_search_utils(grid, startNode, finishNode, visitedNodesInOrder);\r\n    return visitedNodesInOrder;\r\n}\r\n\r\nfunction breadth_first_search_utils(grid, startNode, finishNode, visitedNodesInOrder) {\r\n    // if (node.row === finishNode.row && node.col === finishNode.col) {\r\n    //     return true;\r\n    // }\r\n    const queue = [];\r\n    startNode.isVisited = true;\r\n    queue.unshift(startNode); //add element at begining of the array\r\n\r\n    while (queue.length > 0) {\r\n        const node = queue.pop();\r\n        const unvisitedNeighbors_array = getUnvisitedNeighbors(node, grid);\r\n        for (const i in unvisitedNeighbors_array) {\r\n            if (unvisitedNeighbors_array[i].isVisited || unvisitedNeighbors_array[i].isWall) {\r\n                continue;\r\n            } else {\r\n                unvisitedNeighbors_array[i].previousNode = node;\r\n                queue.unshift(unvisitedNeighbors_array[i]);\r\n                visitedNodesInOrder.push(unvisitedNeighbors_array[i]);\r\n                unvisitedNeighbors_array[i].isVisited = true;\r\n                if (unvisitedNeighbors_array[i].row === finishNode.row && unvisitedNeighbors_array[i].col === finishNode.col) {\r\n                    visitedNodesInOrder.pop();\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfunction getUnvisitedNeighbors(node, grid) {\r\n    const neighbors = [];\r\n    const { col, row } = node;\r\n    if (row > 0) neighbors.push(grid[row - 1][col]);\r\n    if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n    if (col > 0) neighbors.push(grid[row][col - 1]);\r\n    if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n    return neighbors.filter(neighbor => !neighbor.isVisited);\r\n}\r\n\r\nexport function getNodesInShortestPathOrder(finishNode) {\r\n    const nodesInShortestPathOrder = [];\r\n    let currentNode = finishNode;\r\n\r\n    while (currentNode !== null) {\r\n        nodesInShortestPathOrder.unshift(currentNode);\r\n        currentNode = currentNode.previousNode;\r\n    }\r\n    return nodesInShortestPathOrder;\r\n}\r\n","import React, { Component } from \"react\";\r\nimport Node from \"./Node/Node\";\r\nimport \"./DeptFirstSearch.css\";\r\nimport { depth_first_search, getNodesInShortestPathOrder } from \"../graph_algorithms/DepthFirstSearch_algo\";\r\nimport { breadth_first_search } from \"../graph_algorithms/BFS_algo\";\r\n\r\nconst START_NODE_ROW = 10;\r\nconst START_NODE_COL = 15;\r\nconst FINISH_NODE_ROW = 10;\r\nconst FINISH_NODE_COL = 35;\r\n\r\nexport default class DeptFirstSearch extends Component {\r\n    constructor() {\r\n        super();\r\n        this.state = {\r\n            grid: [],\r\n            mouseIsPressed: false\r\n        };\r\n    }\r\n\r\n    componentDidMount() {\r\n        const grid = getInitialGrid();\r\n        this.setState({ grid });\r\n    }\r\n\r\n    handleMouseDown(row, col) {\r\n        const changedGrid = getNewgridWithWallToggled(this.state.grid, row, col);\r\n        this.setState({ grid: changedGrid, mouseIsPressed: true });\r\n    }\r\n\r\n    handleMouseEnter(row, col) {\r\n        if (!this.state.mouseIsPressed) return;\r\n        const newGrid = getNewgridWithWallToggled(this.state.grid, row, col);\r\n        this.setState({ grid: newGrid });\r\n    }\r\n\r\n    handleMouseUp() {\r\n        this.setState({ mouseIsPressed: false });\r\n    }\r\n\r\n    animateShortestPath(nodesInShortestPathOrder) {\r\n        for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\r\n            if (nodesInShortestPathOrder[i].isStart || nodesInShortestPathOrder[i].isFinish) {\r\n                continue;\r\n            }\r\n            setTimeout(() => {\r\n                const node = nodesInShortestPathOrder[i];\r\n                document.getElementById(`node-${node.row}-${node.col}`).className = \"node node-shortest-path\";\r\n            }, 10 * i);\r\n        }\r\n    }\r\n\r\n    animateDFS(visitedNodesInOrder, nodesInShortestPathOrder) {\r\n        for (let i = 0; i <= visitedNodesInOrder.length; i++) {\r\n            if (i == visitedNodesInOrder.length) {\r\n                setTimeout(() => {\r\n                    this.animateShortestPath(nodesInShortestPathOrder);\r\n                }, 10 * i);\r\n                return;\r\n            }\r\n            setTimeout(() => {\r\n                const node = visitedNodesInOrder[i];\r\n                document.getElementById(`node-${node.row}-${node.col}`).className = \"node node-visited\";\r\n            }, 10 * i);\r\n        }\r\n    }\r\n\r\n    visualizeDeptFirstSearch() {\r\n        const { grid } = this.state;\r\n        const starNode = grid[START_NODE_ROW][START_NODE_COL];\r\n        const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\r\n        const visitedNodesInOrder = depth_first_search(grid, starNode, finishNode);\r\n        const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\r\n        this.animateDFS(visitedNodesInOrder, nodesInShortestPathOrder);\r\n    }\r\n\r\n    visualizeBreadthFirstSearch() {\r\n        const { grid } = this.state;\r\n        const starNode = grid[START_NODE_ROW][START_NODE_COL];\r\n        const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\r\n        const visitedNodesInOrder = breadth_first_search(grid, starNode, finishNode);\r\n        const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\r\n        this.animateDFS(visitedNodesInOrder, nodesInShortestPathOrder);\r\n    }\r\n\r\n    render() {\r\n        const { grid, mouseIsPressed } = this.state;\r\n        return (\r\n            <>\r\n                <button onClick={() => this.visualizeDeptFirstSearch()}>Visual DFS</button>\r\n                <button onClick={() => this.visualizeBreadthFirstSearch()}>Visual BFS</button>\r\n                <div className=\"grid\">\r\n                    {grid.map((row, rowIdx) => {\r\n                        return (\r\n                            <div key={rowIdx}>\r\n                                {row.map((node, nodeIdx) => {\r\n                                    const { row, col, isStart, isFinish, isWall } = node;\r\n                                    return (\r\n                                        <Node\r\n                                            key={nodeIdx}\r\n                                            row={row}\r\n                                            col={col}\r\n                                            isStart={isStart}\r\n                                            isFinish={isFinish}\r\n                                            isWall={isWall}\r\n                                            mouseIsPressed={mouseIsPressed}\r\n                                            onMouseDown={(row, col) => this.handleMouseDown(row, col)}\r\n                                            onMouseUp={() => this.handleMouseUp()}\r\n                                            onMouseEnter={(row, col) => this.handleMouseEnter(row, col)}\r\n                                        ></Node>\r\n                                    );\r\n                                })}\r\n                            </div>\r\n                        );\r\n                    })}\r\n                </div>\r\n            </>\r\n        );\r\n    }\r\n}\r\n\r\nconst getInitialGrid = () => {\r\n    const grid = [];\r\n    for (let row = 0; row < 20; row++) {\r\n        const currentRow = [];\r\n        for (let col = 0; col < 50; col++) {\r\n            currentRow.push(createNode(row, col));\r\n        }\r\n        grid.push(currentRow);\r\n    }\r\n    return grid;\r\n};\r\n\r\nconst createNode = (row, col) => {\r\n    return {\r\n        row,\r\n        col,\r\n        isStart: row === START_NODE_ROW && col === START_NODE_COL,\r\n        isFinish: row === FINISH_NODE_ROW && col === FINISH_NODE_COL,\r\n        isWall: false,\r\n        isVisited: false,\r\n        distance: Infinity,\r\n        previousNode: null\r\n    };\r\n};\r\n\r\nconst getNewgridWithWallToggled = (grid, row, col) => {\r\n    const newGrid = grid.slice();\r\n    const node = newGrid[row][col];\r\n    const newNode = {\r\n        ...node,\r\n        isWall: !node.isWall\r\n    };\r\n    newGrid[row][col] = newNode;\r\n    return newGrid;\r\n};\r\n","import React from \"react\";\nimport logo from \"./logo.svg\";\nimport \"./App.css\";\nimport DeptFirstSearch from \"./DeptFirstSearch/DeptFirstSearch\";\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <DeptFirstSearch></DeptFirstSearch>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}